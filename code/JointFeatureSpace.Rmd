---
title: R Notebook of studies into defining joint neuronal scATAC feature space for
  mouse CNS tissues E12-E15
output:  html_notebook
---

```{r Libraries, include=FALSE}
library(Seurat)
library(Signac)
library(tidyverse)
library(BSgenome.Mmusculus.UCSC.mm10)
library(RColorBrewer)
library(future)
library(GenomicRanges)
library(EnsDb.Mmusculus.v79)
library(dendextend)
library(DT)
library(BiocManager)
library(ChIPpeakAnno)

source("../../generic code/AuxFunctions.R")
```

```{r Setting multicore/multisession}
options(parallelly.makeNodePSOCK.setup_strategy = "sequential", future.globals.maxSize = 12 * 1024 ^ 3, future.seed=TRUE)
plan("multisession", workers = 6)
```

```{r Path to raw data}
raw.path <- "/Volumes/ExtSSD/ExtraWorkspace/"
run.date <- "281021"
set.seed(2021)
```

# Defining joint feature space

```{r Reading in Seurat object from each separate sample}
# These already contain merged technical replicates, read count over 5kbp binned mm10 genome
e12r1.merged <- readRDS("../../E12R1/code/E12_R1.merged.clade.phase.221021.Rds")
e14di.merged <- readRDS("../../e14di1/scATAC_data/E14_DI_1.merged.clade.phase.211021.Rds")
e14mb.merged <- readRDS("../../e14vmb1/code/E14_VMB.merged.clade.phase.261021.Rds")
e14vr1.merged <- readRDS("../../e14vR1/code/E14_R1.merged.clade.phase.261021.Rds")
```

```{r Checking that each have exactly the same amount of features (bins)}
e12r1.merged
e14di.merged
e14mb.merged
e14vr1.merged
```

```{r Creating new merged Seurat object from all of samples}
system.time(neuronal.merged <- merge(x = e12r1.merged, y = c(e14di.merged, e14mb.merged, e14vr1.merged), add.cell.ids = c("_e12r1","_e14di", "_e14vmb","_e14vr1")))
```

```{r Checking the size, and presence of fragment file links of fully merged object}
neuronal.merged
str(Fragments(neuronal.merged))
```


```{r Add gene annotations from Ensembl, include=FALSE}
# extract gene annotations from EnsDb
annotations <- readRDS("../../Github/AnalysisEnvironment/mm10/Ensembel_Mmusculus79_annotation.Rds")

# change to UCSC style since the data was mapped to hg19
seqlevelsStyle(annotations) <- 'UCSC'
genome(annotations) <- "mm10"

#ucsc.levels <- str_replace(string=paste("chr",seqlevels(annotations),sep=""), pattern="chrMT", replacement="chrM")
#seqlevels(annotations) <- ucsc.levels

# add the gene information to the object
Annotation(neuronal.merged) <- annotations
```

```{r Calculate nucleosome signal}
neuronal.merged <- NucleosomeSignal(object = neuronal.merged)
```
```{r Plotting Nucleosome signal}
neuronal.merged$nucleosome_group <- ifelse(neuronal.merged$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
FragmentHistogram(object = neuronal.merged, group.by = 'nucleosome_group', region = 'chr1-1-10000000')
```

```{r TSS enrichment}
neuronal.merged <- TSSEnrichment(neuronal.merged, fast = FALSE)
```

```{r Plot biological QC data, fig.width=14}
neuronal.merged$pct_reads_in_peaks <- neuronal.merged$peak_region_fragments / neuronal.merged$passed_filters * 100
neuronal.merged$blacklist_ratio <- neuronal.merged$blacklist_region_fragments / neuronal.merged$peak_region_fragments

VlnPlot(
  object = neuronal.merged,
  features = c('pct_reads_in_peaks', 'peak_region_fragments',
               'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)

```

```{r Storing merged clade level object as it takes so long to form}
saveRDS(neuronal.merged,paste("neuronal.merged.clade.phase.",run.date,".Rds",sep=""))
```

```{r Filter based on biological QC values}
neuronal.merged.filt <- subset(
  x = neuronal.merged,
  subset = peak_region_fragments > 2500 &
    peak_region_fragments < 45000 &
    pct_reads_in_peaks > 55 &
    blacklist_ratio < 0.015 &
    nucleosome_signal < 3 &
    TSS.enrichment > 4.5
)
neuronal.merged.filt
```

```{r Filtering based on number of cells per feature or vice versa}
min.cells.thr <- round(length(unique(Cells(neuronal.merged.filt)))*0.025, digits = 0)
max.cells.thr <- round(length(unique(Cells(neuronal.merged.filt)))*0.975, digits = 0)

min.features.thr <- round(nrow(neuronal.merged.filt)*0.025, digits = 0)
max.features.thr <- round(nrow(neuronal.merged.filt)*0.975, digits = 0)

cell.per.feature <- rowSums(GetAssayData(neuronal.merged.filt[["clade_peaks"]])>0)
feature.per.cell <- colSums(GetAssayData(neuronal.merged.filt[["clade_peaks"]])>0)

feature.filter.index <- which(cell.per.feature >= min.cells.thr & cell.per.feature <= max.cells.thr)
cell.filter.index <- which(feature.per.cell >= min.features.thr & feature.per.cell <= max.features.thr)

features.to.keep <- rownames(neuronal.merged.filt)[feature.filter.index]
cells.to.keep <- Cells(neuronal.merged.filt)[cell.filter.index]

neuronal.merged.filt <- subset(neuronal.merged.filt, cells = cells.to.keep, features = features.to.keep)
neuronal.merged.filt
```


```{r RUN TFIDF for the purpose of clade detection}
neuronal.merged.filt[["clade_peaks_count"]] <- neuronal.merged.filt[["clade_peaks"]]
DefaultAssay(neuronal.merged.filt) <- 'clade_peaks'
neuronal.merged.filt <- BinarizeCounts(neuronal.merged.filt, assay = "clade_peaks")
neuronal.merged.filt <- RunTFIDF(neuronal.merged.filt)
neuronal.merged.filt <- FindTopFeatures(neuronal.merged.filt, min.cutoff = 'q5')
neuronal.merged.filt <- RunSVD(object = neuronal.merged.filt)
```


```{r Correlation between depth and reduced dimension components}
DepthCor(neuronal.merged.filt)
```

```{r Take approximate right singular vectors, matrix multiplication with singular values and transpose}
SVD.d <- neuronal.merged.filt@reductions$lsi@misc$d
SVD.u <- neuronal.merged.filt@reductions$lsi@misc$u
num.dimensions <- ncol(neuronal.merged.filt@reductions$lsi)
d_diagtsne = matrix(0, nrow=num.dimensions, ncol=num.dimensions)
diag(d_diagtsne) = SVD.d
# Assuming that first principle component is associated with read depth as shown above.
d_diagtsne[1,1] = 0
# Take approximate right singular vectors, matrix multiplication with singular values and transpose
SVDtsne_vd = t(d_diagtsne %*% t(SVD.u))

hclust_cells <- hclust(proxy::dist(SVDtsne_vd, method="cosine"), method="ward.D2")
hcd <- as.dendrogram(hclust_cells)
```

```{r Cut the tree for purpose of visualization h10, fig.width=14}
par(mai=c(2,.5,.25,.25),cex=.75)
h = 10
hcd.cut <- cut(hcd, h = h)
hcd.upper<-hcd.cut$upper
hcd.upper.clusters<-cutree(hcd.upper,h=h)
hcd.upper<-reindex_dend(hcd.upper)
# Find out why this needs to be done, what is not reset in the object after cut but is reset after conversion back and worth
hcd.upper<-as.dendrogram(as.hclust(hcd.upper))
n.term.nodes <- sapply(hcd.cut$lower,count_terminal_nodes)
hcd.upper<-set_labels(hcd.upper,paste("Clade #",hcd.upper.clusters,"with",n.term.nodes,"cells",sep=" "))
color_branches(hcd.upper,clusters=hcd.upper.clusters,col=color.vector(hcd.upper.clusters)) %>% set("branches_lwd",5) %>% set("labels_cex",1.2) %>% plot(center=T)
abline(h = h, lty = 2, col="red", lwd=2)
```

```{r Cut the tree to find main clades and write those out for summit identification}
cells_tree_cut = cutree(hclust_cells, h=h)
lsi_cells = dplyr::tibble(barcode = Cells(neuronal.merged.filt), cells_tree_cut = cells_tree_cut)
```


```{r See how samples are distributed in clades h10}
sample.clade <- table(str_extract(string = lsi_cells$barcode, pattern = "_.*__") %>% str_replace_all(pattern = "_*", replacement = ""), lsi_cells$cells_tree_cut)
sample.clade
```

Now main question is that what can we assume to be biological in terms of how cells are distributed in this table. Columns are now high level cellular clades with cut height of 10 (meaningful number only in the context of the hiearchical tree above) and numbers reflect how many cells from each sample are in which clades. We cannot entirely remove technical noise from affecting the clustering, though read depth has effect has been significantly reduced with priuor steps. Below same analysis with cut height of 9.

```{r Cut the tree for purpose of visualization h9, fig.width=14}
par(mai=c(2,.5,.25,.25),cex=.75)
h = 9
hcd.cut <- cut(hcd, h = h)
hcd.upper<-hcd.cut$upper
hcd.upper.clusters<-cutree(hcd.upper,h=h)
hcd.upper<-reindex_dend(hcd.upper)
# Find out why this needs to be done, what is not reset in the object after cut but is reset after conversion back and worth
hcd.upper<-as.dendrogram(as.hclust(hcd.upper))
n.term.nodes <- sapply(hcd.cut$lower,count_terminal_nodes)
hcd.upper<-set_labels(hcd.upper,paste("Clade #",hcd.upper.clusters,"with",n.term.nodes,"cells",sep=" "))
color_branches(hcd.upper,clusters=hcd.upper.clusters,col=color.vector(hcd.upper.clusters)) %>% set("branches_lwd",5) %>% set("labels_cex",1.2) %>% plot(center=T)
abline(h = h, lty = 2, col="red", lwd=2)
```

```{r Cut the tree to find main clades and write those out for summit identification h9}
cells_tree_cut = cutree(hclust_cells, h=h)
lsi_cells = dplyr::tibble(barcode = Cells(neuronal.merged.filt), cells_tree_cut = cells_tree_cut)
```

```{r See how samples are distributed in clades h9}
sample.clade <- table(str_extract(string = lsi_cells$barcode, pattern = "_.*__") %>% str_replace_all(pattern = "_*", replacement = ""), lsi_cells$cells_tree_cut)
sample.clade
```

This is now same with cut height of 9.

```{r Cut the tree for purpose of visualization h8, fig.width=14}
par(mai=c(2,.5,.25,.25),cex=.75)
h = 8
hcd.cut <- cut(hcd, h = h)
hcd.upper<-hcd.cut$upper
hcd.upper.clusters<-cutree(hcd.upper,h=h)
hcd.upper<-reindex_dend(hcd.upper)
# Find out why this needs to be done, what is not reset in the object after cut but is reset after conversion back and worth
hcd.upper<-as.dendrogram(as.hclust(hcd.upper))
n.term.nodes <- sapply(hcd.cut$lower,count_terminal_nodes)
hcd.upper<-set_labels(hcd.upper,paste("Clade #",hcd.upper.clusters,"with",n.term.nodes,"cells",sep=" "))
color_branches(hcd.upper,clusters=hcd.upper.clusters,col=color.vector(hcd.upper.clusters)) %>% set("branches_lwd",5) %>% set("labels_cex",1.2) %>% plot(center=T)
abline(h = h, lty = 2, col="red", lwd=2)
```

```{r Cut the tree to find main clades and write those out for summit identification h8}
cells_tree_cut = cutree(hclust_cells, h=h)
lsi_cells = dplyr::tibble(barcode = Cells(neuronal.merged.filt), cells_tree_cut = cells_tree_cut)
```

```{r See how samples are distributed in clades h8}
sample.clade <- table(str_extract(string = lsi_cells$barcode, pattern = "_.*__") %>% str_replace_all(pattern = "_*", replacement = ""), lsi_cells$cells_tree_cut)
sample.clade
```

This is now same with cut height of 8.

Basically lower we cut, more features we will get in subsequent step with Macs2 peak calling algorithm as more rare cell types are allowed to call peaks. Naturally noise and sparseness of the data increases simultaneously. This is ultimately a question of how cells we do require to allow them to call their own peaks. In this last cut height for example clade 45 contains only 139 cells. It might still be ok, but I wouldn't go much further down from that. Clearly E12r1 does not participate in about half of the clades where then cells from three other samples are present. In overall there is quite interesting structure in this table. Please remember that this clustering does not have any further use or meaning, only that peaks of rare cell types get a chance to be called.

```{r Run MACS for clade level peak detection, include=FALSE}
neuronal.merged.filt <- AddMetaData(neuronal.merged.filt, lsi_cells$cells_tree_cut, "clade")
clade.peaks <- CallPeaks(neuronal.merged.filt, macs2.path = "/Users/kilpinen/opt/anaconda3/envs/r411_221021/bin/macs2", effective.genome.size = 1.87e9, group.by = "clade", combine.peaks = TRUE, name = paste(sample.name,"_per_clade_peaks_merged", sep=""))
```

```{r Just sanity check of peaks called over the genome}
clade.peaks
```

```{r Store clade peaks for further use}
saveRDS(clade.peaks,paste("joint.clade.peaks.h8.",run.date,".Rds",sep=""))
```

# Looking for correspondence between joint feature space and separate ones

```{r Loading separately generated feature spaces}
clade.peaks.di <- readRDS("../../e14di1/scATAC_data/clade.peaks.Rds")
clade.peaks.e12r1 <- readRDS("../../E12R1/scATAC_data/clade.peaks.191021.Rds")
clade.peaks.e14vmb1 <- readRDS("../../e14vmb1/scATAC_data/clade.peaks.Rds")
clade.peaks.e14vr1 <- readRDS("../../e14vR1/code/E14_R1.021121.cladepeaks.Rds")
```

```{r}
clade.peaks
```

There are 424 411 features in jointly defined feature space

```{r}
clade.peaks.di
```

Vs. for example 287 587 features in separately defined E14Di feature space.

```{r}
hits <- findOverlaps(clade.peaks, clade.peaks.di)
overlaps <- pintersect(clade.peaks[queryHits(hits)], clade.peaks.di[subjectHits(hits)])
percentOverlap <- width(overlaps) / width(clade.peaks.di[subjectHits(hits)])
hist(percentOverlap, main = "Hist. of E14di separate feature space feature overlaps with the joint one")
hits <- hits[percentOverlap > 0.8]
```

```{r}
hits <- findOverlaps(clade.peaks.di, clade.peaks)
overlaps <- pintersect(clade.peaks.di[queryHits(hits)], clade.peaks[subjectHits(hits)])
percentOverlap <- width(overlaps) / width(clade.peaks[subjectHits(hits)])
hist(percentOverlap, main = "Hist. of joint features space feature overlaps with the E14DI separate one")
```

However, larger space pretty much includes the separate one with very high overlaps between features. I am extremely positively surprised by this. Result is very good and encouraging. The fact that joint feature space is 2x of separately defined one is perfectly ok, and kind of assumed as well. When joint feature space is used for any individual sample these extra features do not matter, they will filter away if sample in question does not have reads for them. This still does not answer to the question of optimal cut height, but at least this level 8 does look quite good.

```{r VENN diagram Joint vs E14DI vs E14vMB}
makeVennDiagram(Peaks=list(clade.peaks,clade.peaks.di, clade.peaks.e14vmb1), NameOfPeaks = c("Joint space","E14DI", "E14vMB"), minoverlap = 100)
```

```{r VENN diagram of E12R1 vs E14R1 vs joint space}
makeVennDiagram(Peaks=list(clade.peaks,clade.peaks.e14vr1, clade.peaks.e12r1), NameOfPeaks = c("Joint space","E14vR1","E12R1"), minoverlap = 100)
```


```{r VENN diagram with all comparisons}
makeVennDiagram(Peaks=list(clade.peaks,clade.peaks.di, clade.peaks.e14vmb1, clade.peaks.e12r1,clade.peaks.e14vr1), NameOfPeaks = c("Joint space","E14DI", "E14vMB","E12R1","E14vR1"), minoverlap = 100)
```


```{r Env info}
sessionInfo()
```

