---
title: "R Notebook of E14 downstream analysis from binarized peak level data with "
output: html_notebook
---
# R Packages

```{r Load packagies, include=FALSE}
load.libs <- c(
  "viridisLite",
  "DT",
  "GenomicRanges",
  "data.table",
  "plyr",
  "gplots",
  "magrittr",
  "Matrix",
  "proxy",
  "qs",
  "genomation",
  "densityClust",
  "irlba",
  "umap",
  "clusterProfiler",
  "RColorBrewer",
  "openxlsx",
  "gridExtra",
  "Signac",
  "presto",
  "Seurat",
  "regioneR",
  "reldist",
  "SeuratWrappers",
  "chromVAR",
  "tidyverse",
  "TFBSTools",
  "BSgenome.Mmusculus.UCSC.mm10",
  "EnsDb.Mmusculus.v79",
  "org.Mm.eg.db",
  "plotly",
  "ggplotify",
  "motifmatchr",
  "future",
  "circlize",
  "cowplot",
  "universalmotif",
  "readxl",
  "ComplexHeatmap")
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(load.libs, update = FALSE, character.only = TRUE, install = FALSE)
status <- sapply(load.libs,require,character.only = TRUE)
if(all(status)){
    print("SUCCESS: You have successfully installed and loaded all required libraries.")
} else{
    cat("ERROR: One or more libraries failed to install correctly. Check the following list for FALSE cases and try again...\n\n")
    status
}

source("../../generic code/AuxFunctions.R")
set.seed(2020);
```

# Reading datafiles

```{r Setwd sample name specific variables, message=FALSE}
sample.name <- "E14"
run.date <- "300922"
supp_data_path <- "~/Workspace/mm10/"
cores=6
std.aim <- 0.15
```

```{r Setting Seurat multicore}
plan("multisession", workers = cores)
options(future.globals.maxSize = 12 * 1024 ^ 3, future.seed=TRUE, future.rng.onMisuse="ignore")
```

```{r Reading in data objects}
s.data <- readRDS(paste("../scATAC_data/",sample.name,".merged.peaks.298622.Rds",sep=""))
s.data_RNA <- readRDS("../scRNA_data/E14scRNAseq.300822.Rds")
```

```{r}
s.data <- AddMetaData(object = s.data, metadata = str_extract(colnames(s.data), pattern = "[a-z]{2}_\\d{1}|[r1]{2}_\\d{1}"), col.name = "brain_region.replicate")
s.data <- AddMetaData(object = s.data, metadata = str_extract(colnames(s.data), pattern = "[a-z]{2}|[r1]{2}"), col.name = "brain_region")
```

```{r TFIDF and SVD, message=FALSE}
DefaultAssay(s.data) <- 'peaks'

set.seed(2020)

s.data <- RunTFIDF(s.data, method=3)
s.data <- FindTopFeatures(s.data, min.cutoff = 'q0')
s.data <- RunSVD(
  object = s.data,
  assay = 'peaks',
  reduction.key = 'LSI_',
  reduction.name = 'lsi',
  n=60
)
```

```{r Plot depth dimension correlation}
DepthCor(s.data)
```

```{r Calculate proportion of stdebv covered by LSI components in comparison to 2}
std.proportion <- sapply(2:length(s.data@reductions$lsi@stdev),function(x){s.data@reductions$lsi@stdev[x]/s.data@reductions$lsi@stdev[2]})

# Finding number of components of which std proportion to 2nd component is closest to std.aim
max.lsi.dim <- which.min(abs(std.proportion-std.aim))
```

# scATAC UMAP clusters

```{r UMAP and community detection, fig.width=14, fig.height=14}
# Initial UMAP
s.data <- RunUMAP(object = s.data, reduction = 'lsi', dims = 2:max.lsi.dim)
s.data <- FindNeighbors(object = s.data, reduction = 'lsi', dims = 2:max.lsi.dim)
suppressWarnings(s.data <- FindClusters(object = s.data, verbose = FALSE, algorithm = 4, resolution = 4))
DimPlot(object = s.data, label = TRUE, pt.size=1.2, label.size = 8) + NoLegend()
```

```{r Plot replicate distribution, fig.width=14, fig.height=14}
DimPlot(object = s.data, label = TRUE, pt.size=.8,group.by="replicate", shuffle =TRUE, label.size = 8) + NoLegend()
```

# RNA activity estimation

```{r Create estimated gene activity assay}
# Let's extract genomic annotation metadata from s.data[['peaks']]
genomic.metadata <- mcols(Annotation(s.data[['peaks']]))
# Generate conversion table from gene_name to gene_id
gene_name2gene_id <- as_tibble(genomic.metadata[,c("gene_name","gene_id")])

# Calculate gene activity estimate from scATAC reads based on the scATAC, by using gene_names as function does not support any other id
gene.activities <- GeneActivity(s.data, assay="peaks")

# Store gene_names
gene.names <- rownames(gene.activities)

# Switch sparse matrix to use ensmusg id
ensmusg.ids <- gene_name2gene_id[match(gene.names,pull(gene_name2gene_id,"gene_name")),] %>% pull("gene_id")
gene_names <- gene_name2gene_id[match(gene.names,pull(gene_name2gene_id,"gene_name")),] %>% pull("gene_name")

# Dropping NAs
non.na.i <- !is.na(ensmusg.ids)
gene.activities.gene_id <- gene.activities[non.na.i,]
rownames(gene.activities.gene_id) <- ensmusg.ids[non.na.i]

# Add the gene activity matrix to the Seurat object as a new assay
s.data[['Activity']] <- CreateAssayObject(counts = gene.activities.gene_id)
s.data <- NormalizeData(
  object = s.data,
  assay = 'Activity',
  normalization.method = 'LogNormalize',
  scale.factor = median(s.data$nCount_Activity)
)

# Add gene_name to gene_id mapping into the s.data[['Activity']] assays metadata
s.data[['Activity']]<- AddMetaData(s.data[['Activity']], col.name = "feature_symbol", metadata = gene_names[non.na.i])
```

```{r Save temp version}
#qsave(s.data, file = "../scATAC_data/E14_merged_temp.qs", nthreads = 6)
s.data <- qread("../scATAC_data/E14_merged_temp.qs", nthreads = 6)
```

```{r Read marker gene list and do FeaturePlot based on gene activity, fig.height=20, fig.width=20, message=FALSE}
neuronal.markers<- read_tsv("../../CellAnnotation/CellTypeMarkers_E14.tsv", col_names = c("annotation","geneName"))
feature.metadata <- s.data[['Activity']][[]] %>% rownames_to_column(var="gene_id") %>% as_tibble()
neuronal.markers.tmp <- filter(feature.metadata, feature_symbol %in% neuronal.markers$geneName)

neuronal.markers.ids <- pull(neuronal.markers.tmp,"gene_id")
neuronal.markers.names <- pull(neuronal.markers.tmp,"feature_symbol")

DefaultAssay(s.data) <- 'Activity'

f.plot.tmp <- FeaturePlot(
  object = s.data,
  features = neuronal.markers.ids,
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = F
)

f.plots.1 <- lapply(1:length(f.plot.tmp),function(i){
  f.plot.tmp[[i]] + labs(title=neuronal.markers.names[i])
})

patchwork::wrap_plots(f.plots.1)
```

# RNA integration

```{r Perform label transfer}
s.data_RNA@meta.data$CellType<-s.data_RNA@meta.data$seurat_cluster

# Finding transfer anchors
transfer.anchors <- FindTransferAnchors(
    reference = s.data_RNA,
    query = s.data,
    reduction = 'cca',
    reference.assay="RNA",
    query.assay = "Activity",
    features = VariableFeatures(object=s.data_RNA)
)

predicted.labels <- TransferData(   
  anchorset = transfer.anchors,
  refdata = s.data_RNA@meta.data$CellType,
  weight.reduction = s.data[['lsi']],
  dims = 2:max.lsi.dim
)

predicted.NT.labels <- TransferData(
  anchorset = transfer.anchors,
  refdata = s.data_RNA@meta.data$NT.type,
  weight.reduction = s.data[['lsi']],
  dims = 2:max.lsi.dim
)

s.data <- AddMetaData(object = s.data, metadata = apply(predicted.NT.labels,1,max), col.name ="RNA.predicted.NT")
s.data <- AddMetaData(s.data, metadata = predicted.labels)
```

```{r Plot prediction scores, echo=FALSE}
pred.score.df <- data.frame(pred.score=s.data$prediction.score.max)
ggplot(pred.score.df, aes(x=pred.score)) + geom_histogram(binwidth=.025) + geom_vline(data=pred.score.df, aes(xintercept=0.5, color="red"),linetype="dashed") + theme(legend.position = 'none')
```

```{r Calculate accepted prediction score fraction}
prediction.score.over.th <- table(s.data$prediction.score.max > 0.5)
p.freq <- prediction.score.over.th['TRUE']/(prediction.score.over.th['TRUE']+prediction.score.over.th['FALSE'])

p.score.th <- as.numeric(prediction.score.over.th)
val_names <- sprintf("%s (%s)", c("Match not found", "Match found"), scales::percent(round(p.score.th/sum(p.score.th), 2)))
val_names
```

```{r Perform scRNA data imputation, message=FALSE, include = FALSE}
refdata <- GetAssayData(s.data_RNA, assay = "RNA", slot = "data")

s.data_RNA@meta.data$tech<-"scRNA"
s.data@meta.data$tech<-"scATAC"

imputation <- TransferData(anchorset = transfer.anchors, refdata = refdata, weight.reduction = s.data[["lsi"]], dims = 2:max.lsi.dim)

s.data[["RNA"]] <- imputation
coembed <- merge(x = s.data_RNA, y = s.data)

# Copy feature metadata from s.data_rna to s.data
s.data_rna.feature.metadata <- s.data_RNA[["RNA"]][[]]
s.data[["RNA"]] <- AddMetaData(s.data[["RNA"]], metadata = s.data_rna.feature.metadata[rownames(s.data[["RNA"]]),"feature_symbol"], col.name = "feature_symbol")

# Find variable features
coembed <- FindVariableFeatures(coembed)

# Finally, we run PCA and UMAP on this combined object, to visualize the co-embedding of both datasets
coembed <- ScaleData(coembed, do.scale = FALSE)
coembed <- RunPCA(coembed, verbose = FALSE)
coembed <- RunUMAP(coembed, dims = 2:30)
coembed@meta.data$CellType <- ifelse(!is.na(coembed@meta.data$CellType), coembed@meta.data$CellType, coembed@meta.data$predicted.id)
```

    Finding integration vectors

    Finding integration vector weights

    Transfering 27999 features onto reference data

    Centering data matrix

    11:43:23 UMAP embedding parameters a = 0.9922 b = 1.112

    11:43:23 Read 10354 rows and found 29 numeric columns

    11:43:23 Using Annoy for neighbor search, n_neighbors = 30

    11:43:23 Building Annoy index with metric = cosine, n_trees = 50

    0%   10   20   30   40   50   60   70   80   90   100%

    [----|----|----|----|----|----|----|----|----|----|

    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *

    |

    11:43:28 Writing NN index file to temp file /var/folders/yb/wvk8t07s719136klxnc8nmp9sglf93/T//Rtmpnq8Zdj/file72653e114263

    11:43:28 Searching Annoy index using 1 thread, search_k = 3000

    11:43:32 Annoy recall = 100%

    11:43:32 Commencing smooth kNN distance calibration using 1 thread

    11:43:35 Initializing from normalized Laplacian + noise

    11:43:35 Commencing optimization for 200 epochs, with 432826 positive edges

    11:43:45 Optimization finished

```{r Plot coembed data based on technology and cell type, cache=TRUE}
p1 <- DimPlot(coembed, group.by = "tech", shuffle=TRUE)
p2 <- DimPlot(coembed, group.by = "CellType", label = TRUE, repel = TRUE)  + theme(legend.position="none")

p1 + p2
```

```{r Filtering Seurat data object based on prediction score for all downstream analysis}
s.data <- subset(s.data, subset = prediction.score.max > 0.5)
```

```{r Storing old ident set}
DefaultAssay(s.data) <- "peaks"
s.data[['All_ATAC_idents']] <- Idents(s.data)
```

# Calculate NT typing for cells

```{r NT typing preparation}
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

NT.type.markers <- gene_set_prepare2("../onlyNT_markers280722.xlsx", "Brain")

#Renaming genes as gene names instead of ENSMUSG IDs
s.data<-RenameGenesSeurat(s.data,s.data[["RNA"]]@meta.features[,1])
DefaultAssay(s.data) <- 'RNA_name'

#Creating scores for artificial genes: s & g2m
s.data <- CellCycleScoring(
  object = s.data,
  g2m.features = str_to_title(cc.genes$g2m.genes),
  s.features = str_to_title(cc.genes$s.genes),
  search=TRUE
)

#Getting the expression data from the seurat object
exp.matr <- as.matrix(s.data[["RNA_name"]]@data)
#Adding the two 'genes' in the end of the matrix
matr <- rbind(exp.matr, s.data@meta.data$S.Score)
rownames(matr)[nrow(matr)] <- "S"
matr <- rbind(matr, s.data@meta.data$G2M.Score)
rownames(matr)[nrow(matr)] <- "G2m"
# scale the data 
matr <- t(scale(t(matr)))
```

```{r Calculating NT type estimation per cell}
# Getting cell-type by cell matrix.
es.max <- sctype_score(scRNAseqData = matr, scaled = TRUE, gs = NT.type.markers$gs_positive, gs2 = NT.type.markers$gs_negative)
s.data <- AddMetaData(object=s.data,metadata = apply(es.max,2,function(x){names(which.max(x))}), col.name = "NT.type")
```


# Recalculate LSI and UMAP

```{r Recalculate LSI after scRNA mapping score subsetting}
DefaultAssay(s.data) <- "peaks"

s.data <- RunTFIDF(s.data, method=3)
s.data <- FindTopFeatures(s.data, min.cutoff = 'q0')
s.data <- RunSVD(
  object = s.data,
  assay = 'peaks',
  reduction.key = 'LSI_',
  reduction.name = 'lsi',
  n=60
)
```

```{r Recalculate proportion of stdebv covered by LSI components in comparison to 2}
std.proportion <- sapply(2:length(s.data@reductions$lsi@stdev),function(x){s.data@reductions$lsi@stdev[x]/s.data@reductions$lsi@stdev[2]})

# Finding number of components of which std proportion to 2nd component is closest to std.aim
max.lsi.dim.re <- which.min(abs(std.proportion-std.aim))
```

```{r Recalculate UMAP after filtering cells based on RNA integration score}
s.data <- RunUMAP(object = s.data, reduction = 'lsi', dims = 2:max.lsi.dim.re)
s.data <- FindNeighbors(object = s.data, reduction = 'lsi', dims = 2:max.lsi.dim.re, graph.name = c("N.lsi.peaks","S.lsi.peaks"))
qsave(s.data, file="../scATAC_data/s.data.merged.for.chooseR_q0.290922.qs", nthreads = 6)
```

```{r Calculate optimal r with chooseR on HPC side}
# Using script choose_R_server_side.R 
# TODO: Sort out where this code is to be stored, and how we refer to modified chooseR code

# Summarize results with chooseR_results.R
```


```{r Recalculate community detection with chosen r, fig.height=16, fig.width=16}
r <- 8
suppressWarnings(s.data <- FindClusters(object = s.data, verbose = FALSE, algorithm = 4, resolution = r, random.seed=2020, reduction="lsi", graph.name = "S.lsi.peaks"))

DimPlot(object = s.data, label = TRUE, pt.size=1, label.size = 6) + NoLegend() + coord_fixed()
```

```{r}
# Read scores into current R process
scores <- readRDS("../chooseR/results_leiden_100_q0_290922/scores.Rds")

# Add cluster specific silhouette scores as metadata to s.data? Is there cell specific? Check publication
s.data <- AddMetaData(object = s.data, metadata = scores$avg_sil[match(as.numeric(s.data$S.lsi.peaks_res.8), scores$cluster)], col.name = "silh.score")
create_dt(scores)
```


```{r Calculate confusion table with NT types and cluster labels}
NT.conf.table <- table(s.data$seurat_clusters,s.data$NT.type)
NT.purity<-sum(apply(NT.conf.table,1,function(x){max(x)}))/sum(NT.conf.table)
create_dt(as.data.frame.matrix(NT.conf.table))
```

# Plot marker gene FeaturePlots with imputed scRNA data

```{r Plot marker gene FeaturePlots with imputed scRNA data, fig.height=26, fig.width=20, cache=TRUE, message=FALSE}
DefaultAssay(s.data) <- "RNA_name"

progenitor.patterning <- c("Sox2","Nkx2-1","Nkx2-2", "Nkx6-1", "Otx2")
GABAergic <- c("Sox21","Ascl1","Gad1","Gad2", "Slc32a1")
GABA.precursor.fate <- c("Helt","Gata2","Gata3","Tal1","Lhx6","Dlx1","Dlx2","Arx")
glutamatergic <- c("Neurog2","Pou4f1","Gls","Slc17a6")
cholinergic <- c("Phox2b","Isl1","Chat","Slc18a3")
dopaminergic <- c("Foxa1","Ddc","Th","Slc18a2")
serotonergic <- c("Pitx3", "Lmx1a","Fev","Tph2","Slc6a4")
adrenergic <- c("En1", "Phox2a","Dbh")

progenitor.plots <- FeaturePlot(
  object = s.data,
  features = c(progenitor.patterning),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 5
) & coord_fixed()

GABAergic.plots <- FeaturePlot(
  object = s.data,
  features = c(GABAergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 5
) & coord_fixed()

GABA.precursor.fate.plots <- FeaturePlot(
  object = s.data,
  features = c(GABA.precursor.fate),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 4
) & coord_fixed()

glutamatergic.plots <- FeaturePlot(
  object = s.data,
  features = c(glutamatergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 4
) & coord_fixed()

cholinergic.plots <- FeaturePlot(
  object = s.data,
  features = c(cholinergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 4
) & coord_fixed()

dopaminergic.plots <- FeaturePlot(
  object = s.data,
  features = c(dopaminergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 4
)  & coord_fixed()

serotonergic.plots <- FeaturePlot(
  object = s.data,
  features = c(serotonergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 5
) & coord_fixed()

adrenergic.plots <- FeaturePlot(
  object = s.data,
  features = c(adrenergic),
  pt.size = 0.1,
  max.cutoff = 'q95',
  combine = T, ncol = 3
) & coord_fixed()

patchwork::wrap_plots(progenitor.plots,GABAergic.plots, GABA.precursor.fate.plots,glutamatergic.plots,cholinergic.plots,dopaminergic.plots,serotonergic.plots,adrenergic.plots, nrow = 9, heights=c(1/9,1/9,2.6/9,1/9,1/9,1/9,1/9,1/9))

ggsave(file="/Users/kilpinen/OneDrive - University of Helsinki/Neuronal Feature Space/Figures/plots for figures/Marker_featureplots.pdf", width = 20, height = 26)

```

```{r Dotplot of markers, fig.width=24, fig.height=30}
DotPlot(object = s.data, cluster.idents=TRUE, assay="RNA_name", features = c(progenitor.patterning,GABAergic,GABA.precursor.fate, glutamatergic,cholinergic, dopaminergic, serotonergic,adrenergic,c("Npy","Sst","Six3","Slc6a1","Pvalb","Slc1a1","Ache"))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) + ylab("Cluster") + xlab("")

ggsave(file="/Users/kilpinen/OneDrive - University of Helsinki/Neuronal Feature Space/Figures/plots for figures/Marker_dotplot.pdf", width = 24, height = 30)
```


```{r Plot gini index based validation of clustering effectiveness, message=FALSE}
# Define a set of HK genes
hk.genes <- c("RRN18S","Actb","Gapdh","Pgk1","Ppia","Rpl13a","Rplp0","Arbp","B2M","Ywhaz","Sdha","Tfrc","Gusb","Hmbs","Hprt1","Tbp")

hk.genes.id <- convert_feature_identity(s.data, "RNA",features = hk.genes)
neuronal.markers.id <- convert_feature_identity(s.data, "RNA",features = neuronal.markers$geneName)

# Neuronal marker mean per cluster in Cusanovich data
gene.i <- match(neuronal.markers.id,s.data[['RNA']]@data@Dimnames[[1]])
gene.i<-gene.i[!is.na(gene.i)]
barcode.clusters <- s.data@meta.data$seurat_clusters
marker.matrix <- s.data[['RNA']]@data[gene.i,]
marker.tb <- as_tibble(t(as.data.frame(marker.matrix)))
marker.tb<-tibble(marker.tb,cluster=barcode.clusters)
marker.mean <- list()
marker.mean$mean.by.cluster <- marker.tb %>% group_by(cluster) %>% summarize_all(mean)

# HK gene mean per cluster in Cusanovich data
gene.i <- match(hk.genes.id,s.data[['RNA']]@data@Dimnames[[1]])
gene.i<-gene.i[!is.na(gene.i)]
barcode.clusters <- s.data@meta.data$seurat_clusters
marker.matrix <- s.data[['RNA']]@data[gene.i,]
marker.tb <- as_tibble(t(as.data.frame(marker.matrix)))
marker.tb<-tibble(marker.tb,cluster=barcode.clusters)
hk.mean <- list()
hk.mean$mean.by.cluster <- marker.tb %>% group_by(cluster) %>% summarize_all(mean)

# Gini indeces for Cusanovich data
cus.hk.gini <- apply(hk.mean$mean.by.cluster[,-1],2,gini)
cus.neur.gini <- apply(marker.mean$mean.by.cluster[,-1],2,gini)

gini.tb<-tibble(gini.index=c(cus.hk.gini,cus.neur.gini),type=c(rep("hk",length(cus.hk.gini)),rep("neur",length(cus.neur.gini)))) %>%  dplyr::filter(!is.na(gini.index))

ggplot(gini.tb, aes(x=gini.index,y=type,fill="blue"))+geom_boxplot(fill="lightblue")+ theme(legend.position="none") + theme_classic() + theme(text=element_text(size=16))
```

# Calculate pairwise DA chromating between all pairs of clusters

```{r Calculate with DA_features_pairwise.R in HPC cluster}
qsave(s.data, file="../scATAC_data/s.data.res8.qs", nthreads = 6)
```


```{r}
# Read results
da_features <- qread("../scATAC_data/da_features_8.qs", nthreads = 6)

da_bp <- lapply(da_features,function(da.1){
  mclapply(da.1, function(da.2){
    if (is_tibble(da.2)){
      filt.da <- da.2 %>% dplyr::filter((avg_log2FC > 0.75 | avg_log2FC < -0.75) & p_val_adj < 0.05) %>% pull(feature)
      
      if (length(filt.da)>0){
        filt.da <- sum(width(StringToGRanges(filt.da)))
      } else {
        filt.da <- 0
      }
    } else {
      filt.da <- 0
    }
  }, mc.cores=6)
})

dalength.matrix <- sapply(da_bp, unlist)/1000
rownames(dalength.matrix) <- as.character(seq(1,nrow(dalength.matrix),by=1))
colnames(dalength.matrix) <- as.character(seq(1,ncol(dalength.matrix),by=1))
```

```{r Pairwise chromatin DA count}
da_count <- lapply(da_features,function(da.1){
  lapply(da.1, function(da.2){
    if (is_tibble(da.2)){
      filt.da <- da.2 %>% dplyr::filter((avg_log2FC > 0.75 | avg_log2FC < -0.75) & p_val_adj < 0.05) %>% pull(feature)
      if (length(filt.da)>0){
        filt.da <- length(filt.da)
      } else {
        filt.da <- 0
      }
    } else {
      filt.da <- 0
    }
  })
})

dacount.matrix <- sapply(da_count, unlist)
rownames(dacount.matrix) <- as.character(seq(1,nrow(dacount.matrix),by=1))
colnames(dacount.matrix) <- as.character(seq(1,ncol(dacount.matrix),by=1))
```

```{r Draw clustered heatmap of pairwise DA results, fig.width=18, fig.height=18}
col_fun = colorRamp2(c(0, median(dalength.matrix),max(dalength.matrix)), c("white","yellow", "red"))
Heatmap(dalength.matrix, col = col_fun, heatmap_legend_param = list(legend_height = unit(6, "cm"),title="kbp",grid_width = unit(1, "cm"),labels_gp = gpar(col = "black", font = 20)), cluster_rows=TRUE, cluster_columns = TRUE)
```

```{r Histogram of DA feature chromatin kbp level}
hist(dalength.matrix[upper.tri(dalength.matrix)], main = "Histogram of DA feature lengths between all clusters", xlab = "kbp")
```
```{r Histogram of DA feature count}
hist(dacount.matrix[upper.tri(dacount.matrix)], main = "Histogram of DA feature counts between all clusters", xlab = "Feature count")
```
# Adding Motif information into the object

```{r Adding Motif information to the object, echo=FALSE, message=FALSE}
Hocomocov11 <- read_jaspar("../../mm10/HOCOMOCOv11_core_MOUSE_mono_jaspar_format.txt")
names(Hocomocov11) <- lapply(Hocomocov11,function(x){x@name})
Hocomocov11 <- convert_motifs(Hocomocov11, "TFBSTools-PWMatrix")
PWMs <- do.call(PWMatrixList,Hocomocov11)
DefaultAssay(s.data) <- "peaks"

# add motif information
s.data <- Signac::AddMotifs(
  object = s.data,
  genome = BSgenome.Mmusculus.UCSC.mm10,
  pfm = PWMs
)
```

```{r Run ChromVar and save data object}
s.data <- RunChromVAR(
  object = s.data,
  genome = BSgenome.Mmusculus.UCSC.mm10
)
```

```{r Find Closest features for ATAC features}
DefaultAssay(s.data) <- "peaks"
closest.features <- ClosestFeature(s.data, regions=rownames(s.data))
saveRDS(closest.features,file=paste("../analysis/",sample.name,"_nmm_closest_features.",run.date,".Rds",sep=""))
```

# Identification of markers for clusters defined based on various modalities

```{r Identification of UMAP cluster markers per RNA and ATAC, message=FALSE}
DefaultAssay(s.data) <- "RNA"
markers_rna <- as_tibble(presto:::wilcoxauc.Seurat(X = s.data, group_by = "seurat_clusters", assay = 'data', seurat_assay = 'RNA'))

DefaultAssay(s.data) <- "peaks"
markers_atac <- as_tibble(presto:::wilcoxauc.Seurat(X = s.data, group_by = "seurat_clusters", assay = 'data', seurat_assay = 'peaks'))

markers.atac.annotated <- left_join(markers_atac, as_tibble(closest.features), by=c("feature"="query_region"))
```

```{r Find markers for clusters based on chromvar, message=FALSE}
DefaultAssay(s.data) <- "chromvar"
markers_chromvar <- as_tibble(FindAllMarkers(
  object = s.data,
  only.pos = TRUE,
  test.use = 'LR',
  latent.vars = 'nCount_peaks'
)) %>% filter(p_val_adj <= 0.01 & avg_log2FC >= 0.75)
```

```{r Finding overrepresented motifs among markers_atac features, message=FALSE}
DefaultAssay(s.data) <- "peaks"
motif.markers <- markers.atac.annotated %>% filter(logFC > 0.5 & padj <= 0.01) %>% group_by(group) %>% select(feature, group) %>% group_modify(~FindMotifs(object=s.data, features=.x$feature)) %>% filter(pvalue <= 0.01 & fold.enrichment >= 1.5)
```

```{r Calculating top markers for each modality}
top.markers_rna <- as_tibble(markers_rna) %>% dplyr::filter(padj <= 0.01) %>% group_by(group) %>% top_n(n = 25, wt = logFC)
top.markers_rna$feature_symbol <- convert_feature_identity(s.data, "RNA", feature.format="ens", features = pull(top.markers_rna,feature))

top.markers_atac <- as_tibble(markers.atac.annotated) %>% dplyr::filter(padj <= 0.01) %>% group_by(group) %>% top_n(n = 25, wt = logFC)

top.markers_chromvar <- as_tibble(markers_chromvar) %>% dplyr::filter(p_val_adj <= 0.01) %>% group_by(cluster) %>% top_n(n = 25, wt = avg_log2FC)

top.markers_motifs <- as_tibble(motif.markers) %>% dplyr::filter(pvalue <= 0.01) %>% group_by(group) %>% top_n(n = 25, wt = fold.enrichment)

save(list=c("top.markers_rna","top.markers_atac","top.markers_chromvar","top.markers_motifs","closest.features"), file=paste("../analysis/",sample.name,"_RNApos_ATAC_cluster_markers.",run.date,".RData", sep=""))
```

# Saving data for downstream analyses

```{r Saving data for downstream analyses}
saveRDS(s.data,paste("../scATAC_data/",sample.name,"_DownstreamReady.",run.date,".RNA.pos.idents.Rds",sep=""))
qsave(s.data,paste("../scATAC_data/",sample.name,"_DownstreamReady.",run.date,".RNA.pos.idents.qs",sep=""), nthreads = 6)
```

```{r Saving data for downstream analyses slim}
s.data.slim <- s.data
s.data.slim[['peaks_count']] <- NULL
s.data.slim[['Activity']] <- NULL
saveRDS(s.data.slim,paste("../scATAC_data/",sample.name,"_DownstreamReady.",run.date,".RNA.pos.idents_slim.Rds",sep=""))
```

```{r sessionInfo}
# conda env r421
sessionInfo()
```

# Tables

```{r Cross tabulation between scATAC and scRNA based clustering}
scATAC.clusters <- Idents(s.data)
scRNA.clusters <- s.data@meta.data$predicted.id

conf.mat <- table(as.factor(scRNA.clusters),scATAC.clusters)
create_dt(as.data.frame.matrix(conf.mat))
```


```{r NT-type counts and prop}
nt.type.counts_scatac <- table(data.frame(Idents(s.data),s.data$NT.type))
nt.type.prop_scatac <- apply(nt.type.counts_scatac,1,function(x){
  if(sum(x)>0){
    x/sum(x)
    } else {x}
  })

nt.type.counts_scrna <- table(data.frame(Idents(s.data_RNA),s.data_RNA$NT.type))
nt.type.prop_scrna <- apply(nt.type.counts_scrna,1,function(x){
  if(sum(x)>0){
    x/sum(x)
    } else {x}
  })
```



```{r Correspondence scATAC to scRNA heatmap, fig.height=18, fig.width=20}
conf.mat.numeric <- apply(as.matrix.noquote(conf.mat),2,as.numeric)
o = seriate(conf.mat.numeric, method = "BEA_TSP")

col_fun = colorRamp2(c(0, mean(conf.mat),max(conf.mat)), c("white","yellow", "darkgreen"))

column_ha = HeatmapAnnotation(NT_type = anno_barplot(t(nt.type.prop_scatac),gp = gpar(fill = 1:7)), annotation_name_side = "left")

row_ha = rowAnnotation(NT_type = anno_barplot(t(nt.type.prop_scrna[,rownames(conf.mat)]),gp = gpar(fill = 1:7)), annotation_name_side = "top")

lgd1 = Legend(labels = rownames(nt.type.prop_scatac), title = "NT type", legend_gp = gpar(fill = 1:7))
lgd2 = Legend(col_fun=col_fun, title = "Cell count", at = c(0,50, 100, 150, 200, max(conf.mat)))

ht = Heatmap(conf.mat, col = col_fun, heatmap_legend_param = list(legend_height = unit(6, "cm"),title="Cell count",grid_width = unit(1, "cm"),labels_gp = gpar(col = "black", font = 20)), cluster_rows=TRUE, cluster_columns = TRUE, show_row_dend = FALSE, show_column_dend = FALSE, column_names_gp = gpar(fontsize = 8), row_names_gp = gpar(fontsize = 8), bottom_annotation = column_ha,  right_annotation = row_ha, show_heatmap_legend = FALSE)

#ht = Heatmap(conf.mat, col = col_fun, heatmap_legend_param = list(legend_height = unit(6, "cm"),title="Cell count",grid_width = unit(1, "cm"),labels_gp = gpar(col = "black", font = 20)),row_order = get_order(o, 1), column_order = get_order(o, 2), column_names_gp = gpar(fontsize = 8), row_names_gp = gpar(fontsize = 8), bottom_annotation = column_ha,  right_annotation = row_ha, show_heatmap_legend = FALSE)


draw(ht,  padding = unit(c(0.1, 0.1, 0.1, 5), "cm"))
pd = packLegend(lgd1, lgd2)
draw(pd,  x = unit(1, "npc"), y = unit(0.5, "npc"), just = c("right", "top"))
```

```{r Top 25 marker genes per scATAC cluster}
create_dt(as.data.frame.matrix(data.frame(top.markers_rna)))
```
