---
title: "E14Data_thresholds_combos311022"
output: html_document
date: '2022-11-17'
---

```{r Packages, echo=FALSE}
lapply(c("dplyr","Seurat", "tidyverse", "qs", "Signac", "combiroc", "tibble", "parallel"), library, character.only = T)
#source("DataFunctions.R")
#source("AuxFunctions 2.R")
```

```{r Additional functions}
# Function takes 1 cluster and sets the cells to be in group A and all the rest as group B. Returns a dataframe gathered from these to be used in combiroc analysis.
cluster.dfs <- function(obj, cluster){
  
  clust <- top.markers_rna[which(top.markers_rna$group == cluster),]
  clust.features <- clust$feature_symbol
  
  #Data from a cluster's cells and 25 best markers
  clust <- FetchData(object = obj, vars = clust.features, cells = colnames(obj)[Idents(obj) == cluster])
  clust <- clust[, order(colnames(clust))]
  
  #Creating cell_id and Class columns, arranging data into right format
  clust <- rownames_to_column(clust, var = "cell_id")
  clust$Class <- rep(c("A"), time = nrow(clust))
  clust <- select(clust, cell_id, Class, 2:(ncol(clust)-1))
  
  #Getting all other cluster cells and assigning them as group B
  non.clust <- FetchData(object = obj, vars = clust.features, cells = colnames(obj)[Idents(obj) != cluster])
  non.clust <- non.clust[, order(colnames(non.clust))]
  
  #Creating cell_id and Class columns, arranging data into right format
  non.clust <- rownames_to_column(non.clust, var = "cell_id")
  non.clust$Class <- rep(c("B"), time = nrow(non.clust))
  non.clust <- select(non.clust, cell_id, Class, 2:(ncol(non.clust)-1))
  
  #Combining group A and group B for further combiROC analysis
  data.clust <- rbind(clust, non.clust)
  return(data.clust)
  
}



#Function to create RNA_name assay and getting gene names from ensmusg IDs. 
RenameGenesSeurat <- function(obj, newnames) { 
  print("Run this before integration. It only changes obj@assays$RNA@counts, @data and @scale.data.")
  obj[['RNA_name']] <- obj[['RNA']]
  RNA <- obj@assays$RNA_name
  
  #tmp.conv <- tibble(id=RNA@counts@Dimnames[[1]], symbol=newnames)
  
  if (nrow(RNA) == length(newnames)) {
    if (length(RNA@counts)) RNA@counts@Dimnames[[1]]            <- newnames
    if (length(RNA@data)) RNA@data@Dimnames[[1]]                <- newnames
    if (length(RNA@scale.data)) RNA@scale.data@Dimnames[[1]]    <- newnames
    #if (length(RNA@scale.data)) dimnames(RNA@scale.data)[[1]]    <- tmp.conv$symbol[match(dimnames(RNA@scale.data)[[1]],tmp.conv$id)]
  } else {"Unequal gene sets: nrow(RNA) != nrow(newnames)"}
  obj@assays$RNA_name <- RNA
  return(obj)
}


```


```{r Loading data}
#Load sc data
scRNAseqData = qread("../scATAC_data/E14_DownstreamReady.311022.RNA.pos.idents.qs", nthreads = 4); #load scRNA-seq matrix
DefaultAssay(scRNAseqData) <- 'RNA_name'
```


```{r Top markers}
#Load top RNA markers from e14_counts_to_downstream and filter them further
top.markers_rna <- qread("../analysis/top25_RNA_marker.qs")
top.markers_rna <- top.markers_rna %>% filter(logFC >= 0.75)
```

```{r}
# Go through clusters and find thresholds
E14data <- lapply(1:(length(table(scRNAseqData@meta.data$seurat_clusters))), function(x)
    {cluster.dfs(scRNAseqData, x)})
```

```{r}
# Transforming data in long format for further use
E14data.long <- lapply(E14data, function(x){
  combiroc_long(data = x)
})
```

```{r}
#Questionable: in figure 37=0.88, changed to 1.8
#              in figure 40=1.38, changed to 2
#              in figure 64=0.8, changed to 2
#              in figure 112=1.45, changed to 2
#              in figure 117=0.52, changed to 2
thrh <- c("1"=1.71, "2"=1.62, "3"=1.66, "4"=1.51, "5"=1.28, "6"=1.68, "7"=1.54, 
             "8"=2.65, "9"=1.38, "10"=1.64, "11"=1.93, "12"=1.72, "13"=1.39, "14"=1.27, "15"=2.6,
             "16"=1.48, "17"=1.44, "18"=1.66, "19"=1.26, "20"=1.68, "21"=1.26, "22"=1.19, "23"=1.3,
             "24"=1.13, "25"=1.35, "26"=1.38, "27"=1.57, "28"=1.84, "29"=1.64, "30"=1.39, "31"=1.25,
             "32"=1.42, "33"=1.3, "34"=1.47, "35"=2.77, "36"=2.76, "37"=1.8, "38"=1.73, "39"=1.61,
             "40"=2, "41"=1.61, "42"=1.96, "43"=1.97, "44"=1.36, "45"=2.68, "46"=1.36, "47"=2.47, 
             "48"=1.26, "49"=1.61, "50"=2.58, "51"=2.94, "52"=1.19, "53"=1.44, "54"=1.75, "55"=2.25,
             "56"=2.12, "57"=2.62, "58"=1.74, "59"=1.48, "60"=1.52, "61"=2.2, "62"=1.58, "63"=1.65,
             "64"=2, "65"=1.81, "66"=1.51, "67"=1.48, "68"=2.57, "69"=1.68, "70"=2.75, "71"=1.77,
             "72"=1.8, "73"=1.32, "74"=1.58, "75"=1.48, "76"=1.55, "77"=2.61, "78"=1.38, "79"=1.58,
             "80"=1.48, "81"=2.41, "82"=1.44, "83"=1.05, "84"=1.79, "85"=1.76, "86"=1.65, "87"=1.62,
             "88"=1.61, "89"=1.3, "90"=1.38, "91"=1.4, "92"=1.07, "93"=2.53, "94"=1.37, "95"=1.48,
             "96"=1.53, "97"=2.82, "98"=2.45, "99"=1.2, "100"=1.64, "101"=1.46, "102"=2.2, "103"=2.44,
             "104"=1.33, "105"=1.45, "106"=1.23, "107"=1.58, "108"=1.36, "109"=2.11, "110"=2.33, "111"=2.41,
             "112"=2, "113"=1.84, "114"=2.7, "115"=2.44, "116"=1.48, "117"=2, "118"=1.33, "119"=2.78,
             "120"=1.56, "121"=1.65, "122"=1.43, "123"=1.53, "124"=2.6, "125"=1.42, "126"=2.6, "127"=1.4,
             "128"=2.77, "129"=2.7, "130"=1.74)

```

```{r Combination calculation in HPC}
combos <- mclapply(1:length(thrh), function(x){
  if (ncol(E14data[[x]]) < 8) {
    combi(data = E14data[[x]], signalthr = thrh[[x]], combithr = 2, case_class = "A", max_length = 4)
  }
  else
    combi(data = E14data[[x]], signalthr = thrh[[x]], combithr = 3, case_class = "A", max_length = 6)
}, mc.cores = 12)
saveRDS(combos,"../data/combinations291122.Rds")
```

```{r Combos derived from HPC}
combinations<- readRDS("../data/combinations291122.Rds")

# Ranking combos
ranked.combs <- mclapply(1:length(combinations), function(x){
  tmp.comb <- combinations[[x]]
  rownames(tmp.comb) <- combinations[[x]]$Markers
  combs_SE_SP <- se_sp(data=E14data[[x]], combinations_table=tmp.comb) # compute SE and SP
  combiroc::ranked_combs(data=E14data[[x]], combo_table=combs_SE_SP, min_SE = 40, min_SP = 80,case_class = "A")$table
}, mc.cores=6)
```

```{r Search for maximum Youden value combinations}
# Getting only combos with maximum Youden value
max.combs <- mclapply(1:length(ranked.combs), function(x){
  temp <- rownames_to_column(ranked.combs[[x]],var="Markers") %>% as_tibble(ranked.combs[[x]])
  filter(temp, Youden == max(ranked.combs[[x]]$Youden))
}, mc.cores=6)
```

```{r Look for unique combinations}
# Unique
uniques.clusters <- lapply(max.combs, function(clust){
  uniques <- sapply(clust$Markers, function(row){
    unlist(strsplit(row, split='-'))
  }, simplify = FALSE)
unique(unlist(uniques))
})

```




